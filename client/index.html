<!DOCTYPE html>

<head>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, interactive-widget=resizes-content"/>
    <meta charset="utf-8">
    <title>Krita Remote</title>
    <script type="module">
        import { createApp } from 'https://unpkg.com/vue@3.4.21/dist/vue.esm-browser.js'
        import vue3TouchEvents from "./vue3-touch-events.js"

        const log = (arr, body) => {
            arr.push({body: body})
        }

        const dummy_connection = false
        const send = (socket, msg) => {
            if (!dummy_connection) {
                socket.send(msg)
            } else {
                console.log(msg)
            }
        }

        const get_addr_from_hash = () => {
            try {
                return new URL(location.hash.substring(1))
            } catch (e) {
                return "ws://localhost"
            }
        }

        const build_active_area = (area) => {

            // Tap/Multitap
            const tap = area.getAttribute('tap')
            const multitap = area.getAttribute('multitap')
            area.removeAttribute('tap')
            area.removeAttribute('multitap')
            {
                var html = ""
                if (tap) {
                    area.setAttribute('v-touch:tap','make_touch_handler(\''+tap+'\')')
                    html+= '<div class="tap">'+tap+'</div>'
                }
                if (multitap) {
                    area.setAttribute('v-touch:multitap','make_touch_handler(\''+multitap+'\')')
                    html+= '<div class="multitap">'+multitap+'</div>'
                }
                const origin_label = document.createElement('div')
                origin_label.classList.add(...['origin'])
                origin_label.innerHTML=html
                area.appendChild(origin_label)
            }

            // Orthogonal gestures (swipes/flicks)

            const ortho_gestures = {
                'east':  ['swipe.right', 'multiswipe.right', 'flick.right', 'multiflick.right'],
                'west':  ['swipe.left', 'multiswipe.left', 'flick.left', 'multiflick.left'],
                'north': ['swipe.top', 'multiswipe.top', 'flick.top', 'multiflick.top'],
                'south': ['swipe.bottom', 'multiswipe.bottom', 'flick.bottom', 'multiflick.bottom'],
            }
            for (const direction in ortho_gestures) {
                var dir_html = ""
                const dir_label = document.createElement('div')
                dir_label.classList.add(...[direction])
                    for (const gesture_idx in ortho_gestures[direction]) {
                        const gesture = ortho_gestures[direction][gesture_idx]
                        const gesture_type = gesture.split('.')[0]
                        const action = area.getAttribute(gesture)
                        area.removeAttribute(gesture)
                        if (action) {
                            area.setAttribute('v-touch:'+gesture,"make_touch_handler(\'"+action+"\')")
                            dir_html+="<div class='"+gesture_type+"'>"+action+"</div>"
                        }
                    }
                dir_label.innerHTML=dir_html
                area.appendChild(dir_label)
            }

            // Drag gestures

            const drag = area.getAttribute('drag')
            area.removeAttribute('drag')

            if (drag) {
                area.setAttribute("v-touch:drag","make_drag_handler("+drag+")")
                area.setAttribute("v-touch:release","(event) => {drag_stop()}")
            }

            const label = area.getAttribute('label')
            area.removeAttribute('label')
            if (label) {
                const drag_label = document.createElement('div')
                drag_label.classList.add('origin')
                drag_label.innerHTML = "<div>"+label+"</div>"
                area.appendChild(drag_label)
            }

            // Keypress

            const keypress = area.getAttribute('keypress')
            const multikeypress = area.getAttribute('multikeypress')
            area.removeAttribute('keypress')
            area.removeAttribute('multikeypress')

            {
                var html = ""
                if (keypress) {
                    area.setAttribute("v-touch:press","(event)=> {press('"+keypress+"')}")
                    area.setAttribute("v-touch:release","(event) => {release('"+keypress+"')}")
                    html+= '<div class="tap">'+keypress+'</div>'
                }
                if (multikeypress) {
                    area.setAttribute("v-touch:multipress","(event)=> {press('"+multikeypress+"')}")
                    area.setAttribute("v-touch:multirelease","(event) => {release('"+multikeypress+"')}")
                    html+= '<div class="multitap">'+multikeypress+'</div>'
                }
                if (keypress || multikeypress) {
                    area.setAttribute("v-touch-options","{'disableClick':true}")
                }
                const origin_label = document.createElement('div')
                origin_label.classList.add(...['origin'])
                origin_label.innerHTML=html
                area.appendChild(origin_label)
            }
        }

        document.querySelectorAll('.active-area').forEach(build_active_area)

        const app = createApp({
            data() {
                return {
                    dummy_connection: dummy_connection,
                    connected: false,
                    socket: null,
                    address: get_addr_from_hash(),
                    events: [],
                    drag_started: false,
                    drag_origin_y: 0,
                }
            },
            methods: {
                connect() {
                    this.socket = new WebSocket(this.address);
                    this.socket.addEventListener("open", (event) => {
                        this.connected = true;
                        log(this.events, "socked opened")
                    });
                    this.socket.addEventListener("close", (event) => {
                        this.connected = false;
                        log(this.events, "socket closed")
                    });
                    this.socket.addEventListener("message", (event) => {
                        log(this.events, "message received:" + event.data)
                    })
                },
                promptConnection(event) {
                    this.address = prompt("Connect to WebSocket server", get_addr_from_hash())
                    this.connect()

                },
                action(action_name) {
                    navigator.vibrate(50)
                    log(this.events, action_name)
                    if (this.socket || dummy_connection) {
                        send(this.socket,"action:"+action_name)
                    }
                },
                press(key) {
                    log(this.events, "press:"+key)
                    if (this.socket) {
                        send(this.socket,"press:"+key)
                    }
                },
                release(key) {
                    log(this.events, "release:"+key)
                    if (this.socket) {
                        send(this.socket,"release:"+key)
                    }
                },
                log(arr, msg) {
                    log(arr,msg)
                },
                make_drag_handler(actions) {
                    return (ev) => {
                        if (this.drag_started) {
                            this.drag_continue(ev, actions);
                        } else {
                            this.drag_start(ev);
                            }
                        }
                    },
                make_touch_handler(action_name) {
                    return (ev) => {
                        this.action(action_name);
                        }
                    },
                drag_start(ev) {
                    this.drag_started = true;
                    if (ev.clientY) {
                        this.drag_origin_y = ev.clientY;
                        }
                    if (ev.touches) {
                        this.drag_origin_y = ev.touches[0].clientY;
                        }
                    log(this.events, "drag start");

                },
                drag_continue(ev, actions) {
                    const prev_y = this.drag_origin_y
                    if (ev.clientY) {
                        this.drag_origin_y = ev.clientY;
                    }
                    if (ev.touches) {
                        this.drag_origin_y = ev.touches[0].clientY;
                    }
                    if (prev_y > this.drag_origin_y) {
                        log(this.events, actions['up']);
                        send(this.socket,actions['up']);
                    } else {
                        log(this.events, actions['down']);
                        send(this.socket,actions['down']);
                    }
                },
                drag_stop() {
                    this.drag_started = false;
                }
            },
            mounted() {
                log(this.events, "app mounted")
            }
        }).use(vue3TouchEvents, {})
        app.mount('#app')
    </script>
    <link rel="stylesheet" href="/style.css"></a>
</head>
<body>
    <div id="app" style="padding: 0px; margin: 0px; touch-action: none">
        <div id="pad">
            <div class="active-area col flat-left"
                label="size"
                drag='{"up": "action:increase_brush_size", "down":"action:decrease_brush_size"}'>
            </div>
            <div class="active-area grid9by9 mid-c top-r flat-top"
                tap="eraser_preset_action"
                swipe.right="erase_action"
                swipe.left="clear"
                multiswipe.left="file_quit">
            </div>
            <div class="active-area grid9by9 mid-c mid-r"
                multitap="edit_redo"
                tap="edit_undo"
                swipe.right="edit_paste"
                flick.right="paste_into"
                multiswipe.right="paste_as_reference"
                swipe.bottom="mirror_canvas"
                flick.bottom="zoom_to_100pct"
                swipe.top="edit_copy"
                flick.top="edit_cut"
                swipe.left="file_save"
                flick.left="file_save_as">
            </div>
            <div class="active-area grid9by9 mid-c bot-r flat-bottom"
                keypress="Key_Shift"
                multikeypress="Key_Control">
            </div>
            <div class="active-area col flat-right"
                 label="opacity"
                 drag='{"up": "action:increase_opacity", "down":"action:decrease_opacity"}'>
                </div>
        </div>
        <div v-if="!connected && !dummy_connection" id="connection"
        v-touch:tap="promptConnection" style="justify-items: center">
            <p>Tap anywhere to connect</p>
        </div>
        <ul id="event-log" draggable="false">
            <li v-for="e in events">
                {{ e.body }}
            </li>
        </ul>
    </div>
</body>
